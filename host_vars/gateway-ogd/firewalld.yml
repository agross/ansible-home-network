firewalld:
  services:
    external:
      - dhcpv6-client
      - wireguard

  ipsets:
    public-ip4:
      type: hash:ip

    public-ip6:
      type: hash:ip
      family: inet6
      entries:
        - "{{ network_gateway.ip6 }}"

  rich_rules:
    # IPv6 port forwarding requires the use of the rich language.
    external:
      # HTTP.
      - >-
        rule family=ipv6
        forward-port
          protocol=tcp
          port=80
          to-addr={{ hostvars['proxy-ogd'].interfaces.lan.ip6.address }}
          to-port=80
      # HTTPS.
      - >-
        rule family=ipv6
        forward-port
          protocol=tcp
          port=443
          to-addr={{ hostvars['proxy-ogd'].interfaces.lan.ip6.address }}
          to-port=443
      # HTTP/3.
      - >-
        rule family=ipv6
        forward-port
          protocol=udp
          port=443
          to-addr={{ hostvars['proxy-ogd'].interfaces.lan.ip6.address }}
          to-port=443
      # WebRTC over TCP.
      - >-
        rule family=ipv6
        forward-port
          protocol=tcp
          port=8555
          to-addr={{ hostvars.argus.interfaces.lan.ip6.address }}
          to-port=8555
      # WebRTC over UDP.
      - >-
        rule family=ipv6
        forward-port
          protocol=udp
          port=8555
          to-addr={{ hostvars.argus.interfaces.lan.ip6.address }}
          to-port=8555

    # Same ports as above, but for IPv4 and limited to our public IP.
    # Without limiting to the public IP all port-related traffic would be
    # port-forwarded, making it impossible to access these ports on the
    # internet.
    # https://github.com/firewalld/firewalld/issues/258#issuecomment-453733565
    #
    # Doing the same for IPv6 seems impossible because the proxy replies to
    # the internal host directly, causing a reply from another IP (i.e. not
    # the gateway).
    internal:
      # HTTP.
      - >-
        rule family=ipv4
        destination ipset=public-ip4
        forward-port
          protocol=tcp
          port=80
          to-addr={{ hostvars['proxy-ogd'].interfaces.lan.ip4.address }}
          to-port=80
      # HTTPS.
      - >-
        rule family=ipv4
        destination ipset=public-ip4
        forward-port
          protocol=tcp
          port=443
          to-addr={{ hostvars['proxy-ogd'].interfaces.lan.ip4.address }}
          to-port=443
      # HTTP/3.
      - >-
        rule family=ipv4
        destination ipset=public-ip4
        forward-port
          protocol=udp
          port=443
          to-addr={{ hostvars['proxy-ogd'].interfaces.lan.ip4.address }}
          to-port=443
      # WebRTC over TCP.
      - >-
        rule family=ipv4
        destination ipset=public-ip4
        forward-port
          protocol=tcp
          port=8555
          to-addr={{ hostvars.argus.interfaces.lan.ip4.address }}
      # WebRTC over UDP.
      - >-
        rule family=ipv4
        destination ipset=public-ip4
        forward-port
          protocol=udp
          port=8555
          to-addr={{ hostvars.argus.interfaces.lan.ip4.address }}
          to-port=8555

  forward_ports:
    external:
      # HTTP.
      - proto: tcp
        port: 80
        toaddr: "{{ hostvars['proxy-ogd'].interfaces.lan.ip4.address }}"
        toport: 80
      # HTTPS.
      - proto: tcp
        port: 443
        toaddr: "{{ hostvars['proxy-ogd'].interfaces.lan.ip4.address }}"
        toport: 443
      # HTTP/3.
      - proto: udp
        port: 443
        toaddr: "{{ hostvars['proxy-ogd'].interfaces.lan.ip4.address }}"
        toport: 443
      # WebRTC over TCP.
      - proto: tcp
        port: 8555
        toaddr: "{{ hostvars.argus.interfaces.lan.ip4.address }}"
        toport: 8555
      # WebRTC over UDP.
      - proto: udp
        port: 8555
        toaddr: "{{ hostvars.argus.interfaces.lan.ip4.address }}"
        toport: 8555
